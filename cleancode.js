// 什麼是clean code?
// 1.能通過所有的測試。
// 2.沒有重複的程式碼。
// 3.充分表達系統設計個構思。
// 4.具有最少數量的實體（entities），實體包含類別、方法（methods）、函式或其他欸似的實體等等。

// -- 命名 --
// 讓變數不需要註解就能說明他的用處，都是為了可以更方便閱讀程式碼
// 1.具體描述事件
// 2.數量單位
// 類別(class)的命名應該使用名詞或名詞片語而非動詞
// 函式(function)的命名應該使用動詞或動詞片語

// -- 簡短 --
// If、else、while 及其他敘述都應該只有一行，這意味者，函式不應該大到包含巢狀結構。因此，除非有特殊的需求，否則函式裡的縮排程度應該只能包含 1 ~ 2 層。
// 物件導向的程式語言，應該盡量使用物件導向的優點 this 而不是傳遞 reference。
// 讓函式「只做一件事」，這意味著完整的一件事可以包含他完整的工作，但像順路或隨手幫忙的事情則不在裡面，可以嘗試把函式的內容寫成一段話或文章，可以幫助判別在這件「事」裡面他是否做了其他事情。

// -- 註解 --
// 用snake或camel的命名代替註解
// 有益的註解: 1.法律型註解(如Copyright的註解)
//            2.對意圖的註解，如果沒辦法在少量的敘述內完成說明當變數名稱時，改用註解
//            3.docstring, python中可以用來產生文檔，如此在寫註解的同時也把文檔寫好了

// -- 排版 --
// 遵循規則的空格適當的讓該分開的區域分開可以更方便的閱讀，而在垂直排版上作者提到:「一個被呼叫的函式，應該要出現在『執行呼叫的函式』的下方。」

// -- 資料結構 (Data Structure) 與物件 (Object) --
// Data Structure 直接在外面的資料，可以直接讀取和寫入
// Object         將資料包在裡面，只讓所屬於的函式可以操作他
// 德摩特爾法則 (The Law of Demeter)[最少知識原則]:
//
// 符合 LoD 的函式要求在物件 O 中的函式 m 只能調用以下幾種類型的函式：
// 1. O 本身
// 2. m 的參數
// 3. 在 m 中建立的物件
// 4. 宣告在 O 中的物件
// 5. 被 O 存取的全域變數，並且在 m 的 scope 中
//
// 當你使用資料時要知道自己是拿兩者何者來用，以及怎麼去設定變數，不要讓該私有(private)的變成公用(public)的

// -- 錯誤處理 --
// 使用try當錯誤處裡的流程，不要自己用if/else反覆處裡錯誤
// 不要把try當作if/else來使用
// 在流程上建構出 一般 / 條件下 / 其他情況
// 不要「傳遞」null (不是不要使用null)
// 可以建立一個 Null Object Pattern 當有需要時回傳 Null Object

// -- 邊界 (Boundaries) --
// 分為兩種邊界，一個是與第三方軟體的邊界，另一種是已知與未知的邊界，主要是要區分出程式和程式的邊界
// 在使用第三方軟體時要知道他和自己在寫的程式的區別，最好能使用unit test讓他變成屬於自己的區域，這樣也可以在第三方軟體更新或出錯時可以在unit test的情況下找出錯誤來源
// 而已知和未知間像是要在對接的API還未寫好的情況下要如何進行自己部份的開發，可以先用Fake Statistic來當結果，這樣可以一邊繼續寫自己的部分，在另一邊完成時再讓他來繼承Fake Statistic，讓兩邊做出區隔來，一方面可以各自進行開發不會影響時程，另一方面也可讓兩邊各自成為一個unit

// -- 單元測試(Unit Test) --
// 測試驅動開發(Test-Driven Development 縮寫成TDD) 的三大法則:
// 步驟1: 在撰寫一個單元測試 (測試失敗的單元測試) 前，不可以撰寫任何產品測試。
// 步驟2: 只撰寫剛好無法通過的單元測試。
// 步驟3: 只撰寫剛好能通過當前測試失敗的產品。
// 以上三個步驟可以將我們限制在一個約 30 秒的循環內。
// 有時寫測試語言反而會花更多的時間在寫程式碼，這時用特定領域的測試語言會有更好的效果
// 單元測試也是一個函式只能做一個概念，單元測試也是函式，這意味著要讓他盡可能地只包含一個概念並盡可能的減少Assert，除非為了讓單元測試的有可讀性的原因下也可以增加Assert
// F.I.R.S.T Principle
// First            要快，過長的測試會讓人失去再測試的耐心
// Independent      讓測試不要高度相依另外一個測試，這樣才能確定發生錯誤的是何者
// Repeatable       讓測試在任何環境下都可以成功的執行
// Self-validating  測試應該要輸出boolean值讓人可以快速正確的判讀結果
// Thorought        不只求100%涵蓋率，更該求所有的使用情境
// Timely           測試要在程式撰寫之前寫

// -- 類別 --
// 內聚力 (Cohesion) 指一個函式所操縱的實體變數數量，所操縱的越多內聚力越高
// 單一職責原則 (Single Responsibility Principle, SRP) 和函式一樣讚類別時是「讓一個類別只有一個職責」，判別是否為同一職責時可以檢查類別的名稱和類別內部所做的事情是否一致，以及是否在同一層級
// 開放封閉原則 (Open-Close principle, OCP)  " be open for extension, but closed for modification. "
//   修改具有封閉性: 指不要讓程式間有高度相依性，讓其在修改時不會牽一髮動全身，
//   擴充具有開放性: 指擴充時要盡量在不改動原始碼的狀況下來擴充新功能，如此一來可以減少程式間的相依性
// 里氏替換原則 (Liskov substitution principle, LSP) 要確保在繼承時，盡管 override 部分的程式碼，也能夠讓子類別與副類別的行為兼容。
// 接口遠離原則 (Interface segregation principle, ISP) 一個介面不應該提供過多的方法，可以建立多種的介面，讓需要實作的類別再進行實作。
// 依賴反轉原則 (Dependency inversion principle, DIP) 能夠動態地替換原本依賴的模組
//   隔離修改: 讓程式間減少彼此的依賴性，不要把依賴的程式直接寫在另一個程式碼中，常見的問題像是邊界說到的第三方套件，要想辦法讓主程式和第三方套件的資料分開
//   單元測試: 一樣不要讓單元測試同時測試兩個函式，會讓單元測試很難寫又不好判斷出問題的是哪個程式，可以先把其中一個程式的結果先寫成靜態假資料，如此一來也能減少兩個程式的相依性